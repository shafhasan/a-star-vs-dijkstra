## Introduction
Dijkstra is the most commonly used shortest path algorithm for pathfinding problems. A* is another algorithm that is essentially a copy of Dijkstra, with a single key difference. The concept of a heuristic has been added to A*, which is a lower bound function, and its principal characteristic is to add intelligence to the algorithm in question. When Dijkstra blindly explores nodes to find the least cost shortest path to the goal, A* does an estimate of the cost to the goal by using its heuristic. This allows it to expand fewer nodes compared to Dijkstra and find the shortest path to the goal in much less time.
On a 2D grid, such pathfinding algorithms can be put to the test to see how they perform. These grids have a start and goal node, and obstacles or walls are randomly placed throughout the entire grid. The algorithm has to begin execution from the start node, avoid the obstacles, and reach the goal node. This project aims to compare the performance of both A* and Dijkstra algorithms on grids of increasing size and infer the meaning of the results.

## Implementation
The first step of the implementation is grid generation. We generate grids from user input. The user specifies the number of rows and columns in the grid, as well as a probability. This probability is used to determine whether a cell in the grid will be an obstacle (0 = free, 1 = obstacle). Grids of any size can be created, and obstacles are placed randomly according to this probability. After the grids are generated, the user also specifies the coordinates of the start and goal nodes.
Following this, the different heuristics are defined. We look at the performances of the most commonly used heuristics for A*, namely Manhattan, Euclidean, Octile, and Chebyshev Distance. The user can choose to run A* on any of these, or they can only run Dijkstraâ€™s by choosing no heuristic at all. We implement A* using the heapq module, which provides a priority queue implementation. The algorithm can make either 4-way movements (up, down, left, right) or 8-way movements (4-way + diagonal movements). Based on the selected heuristic, these movements change. Since Manhattan Distance calculates the heuristic for 4-connected grids, the algorithm is also allowed to use only four directions for moving to the goal. For the rest, heuristic calculations are performed considering all directions; hence, the algorithm can move in all directions for those heuristics. Once the algorithm finishes a run, we get to see three things: whether a path was found, the number of nodes visited/expanded, and the time taken to run the algorithm.
To visualize the entire grid and the algorithm working on it, we generate .gif files after each run of the algorithm. The start and goal nodes are marked as green and blue circles, respectively. The visited nodes are colored in yellow, and the path taken to the goal is shown in red.

## Results 
We ran Dijkstra and A* with all four heuristics and on five different grid sizes. We compare the nodes expanded by all of them in the following table:

It is essential to note that the obstacle placements in all five grids and the start-goal node positions were not identical. Although the same probability (0.3) was used for all the grid sizes, the obstacles were not placed in the same cells, since this assignment is randomized. For the same reason, it was not possible to place start and goal nodes in the same positions, since a free cell in one grid might be an obstacle on another. The most effective way to view this table is row-wise, as the grid obstacles remain consistent for the same specified size. But the entire table does give an idea of how the number of expanded nodes changes with the increasing size of the grid.

## Learnings
There are several important details that we noticed upon completing this project. Such as:
In small grids, A* and Dijkstra perform quite similarly i.e. they expand almost the same number of nodes to find the shortest path to the goal. With the increasing size of the grid, the changes become noticeable. Any heuristic used with A* always performs better than Dijkstra.
Moves allowed on the grid are closely related to the heuristic being used. When the Manhattan Distance (MD) heuristic is used to estimate the cost to the goal, it considers a 4-way movement, similar to A*. This does not necessarily mean that using the MD will automatically limit the algorithm to take four types of movements on a grid; the algorithm can also be made to move in eight directions. But in doing so, the heuristic MIGHT become inadmissible in some instances, and the function of using MD is lost. Similarly, for Octile or Chebyshev Distance, the heuristics consider 8-way movements. If the algorithm was allowed to make only 4-way movements, then the same issue could occur.
The Euclidean Distance (ED) heuristic estimates the cost to the goal as the straight-line distance. In a grid with no obstacles, it would find the shortest path along a single vertical, horizontal, or diagonal line. However, due to obstacles, it has to cut corners to reach its goal. Hence, it expands more nodes compared to a grid with no obstacles, and in our scenario, it sometimes performs better than MD and sometimes worse, likely due to the obstacles being more prevalent along its straight-line path.
Between Octile Distance (OD) and Chebyshev Distance (CD), OD performs better in all grid sizes. This is because it performs its estimation by counting the diagonals having 2 cost, whereas CD considers uniform cost (=1) for all movements. Since our grid cells are perfect squares, diagonal movements are more justifiable as 2 instead of 1. Hence, OD provides a close-to-perfect heuristic and thus performs better than CD.
